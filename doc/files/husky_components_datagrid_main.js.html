<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>husky_components/datagrid/main.js - husky</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="husky"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AutoComplete.html">AutoComplete</a></li>
            
                <li><a href="../classes/AutoCompleteList.html">AutoCompleteList</a></li>
            
                <li><a href="../classes/CKEditor.html">CKEditor</a></li>
            
                <li><a href="../classes/Column-Options.html">Column-Options</a></li>
            
                <li><a href="../classes/ColumnNavigation.html">ColumnNavigation</a></li>
            
                <li><a href="../classes/DataGrid.html">DataGrid</a></li>
            
                <li><a href="../classes/Dependant Select.html">Dependant Select</a></li>
            
                <li><a href="../classes/Label.html">Label</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/Matcher.html">Matcher</a></li>
            
                <li><a href="../classes/Overlay.html">Overlay</a></li>
            
                <li><a href="../classes/Process.html">Process</a></li>
            
                <li><a href="../classes/Search.html">Search</a></li>
            
                <li><a href="../classes/Select.html">Select</a></li>
            
                <li><a href="../classes/SmartContent.html">SmartContent</a></li>
            
                <li><a href="../classes/Toggler.html">Toggler</a></li>
            
                <li><a href="../classes/Toolbar.html">Toolbar</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/husky_components_auto-complete.html">husky/components/auto-complete</a></li>
            
                <li><a href="../modules/husky_components_auto-complete-list.html">husky/components/auto-complete-list</a></li>
            
                <li><a href="../modules/husky_components_column-navigation.html">husky/components/column-navigation</a></li>
            
                <li><a href="../modules/husky_components_column-options.html">husky/components/column-options</a></li>
            
                <li><a href="../modules/husky_components_label.html">husky/components/label</a></li>
            
                <li><a href="../modules/husky_components_matcher.html">husky/components/matcher</a></li>
            
                <li><a href="../modules/husky_components_process.html">husky/components/process</a></li>
            
                <li><a href="../modules/husky_components_smart-content.html">husky/components/smart-content</a></li>
            
                <li><a href="../modules/husky_components_toolbar.html">husky/components/toolbar</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: husky_components/datagrid/main.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @class DataGrid
 * @constructor
 *
 * @param {Object} [options] Configuration object
 * @param {Boolean} [options.autoRemoveHandling] raises an event before a row is removed
 * @param {Array} [options.fieldsData] fields data will extend url and set tableHead automatically
 * @param {Object} [options.fieldsData.{}] fields object
 * @param {String} [options.fieldsData.{}.id] field name
 * @param {String} [options.fieldsData.{}.translation] translation key which will be translated automatically
 * @param {String} [options.fieldsData.{}.disabled] either &#x27;true&#x27; or &#x27;false&#x27;
 * @param {Boolean} [options.editable] will not set class is-selectable to prevent hover effect for complete rows
 * @param {String} [options.className] additional classname for the wrapping div
 * @param {Object} [options.data] if no url is provided (some functionality like search &amp; sort will not work)
 * @param {String} [options.defaultMeasureUnit=px] the unit that should be taken
 * @param {String} [options.elementType=table] type of datagrid (currently only table is available)
 * @param {Array} [options.excludeFields=[id]] array of field to exclude
 * @param {Boolean} [options.pagination=false] display a pagination
 * @param {Object} [options.paginationOptions] Configuration Object for the pagination
 * @param {Number} [options.paginationOptions.pageSize] Number of items per page
 * @param {Boolean} [options.paginationOptions.showPages] show pages as visual numbers
 * @param {Number} [options.pageSize] lines per page
 * @param {Number} [options.showPages] amount of pages that will be shown
 * @param {Boolean} [options.removeRow] displays in the last column an icon to remove a row
 * @param {Object} [options.selectItem] Configuration object of select item (column)
 * @param {String} [options.selectItem.type] Type of select [checkbox, radio]
 * @param {String} [options.selectItem.width] Width of select column
 * @param {Boolean} [options.sortable] Defines if list is sortable
 * @param {Array} [options.columns] configuration array of columns
 * @param {String} [options.columns.content] column title
 * @param {String} [options.columns.width] width of column
 * @param {String} [options.columns.class] css class of th
 * @param {String} [options.columns.type] type of the column. Used to manipulate its content (e.g. &#x27;date&#x27;)
 * @param {String} [options.columns.attribute] mapping information to data (if not set it will just iterate of attributes)
 * @param {Boolean} [options.appendTBody] add TBODY to table
 * @param {String} [options.searchInstanceName=null] if set, a listener will be set for the corresponding search event
 * @param {String} [options.columnOptionsInstanceName=null] if set, a listener will be set for listening for column changes
 * @param {String} [options.url] url to fetch data from
 * @param {String} [options.paginationTemplate] template for pagination
 * @param {Boolean} [options.validation] enables validation for datagrid
 * @param {Boolean} [options.addRowTop] adds row to the top of the table when add row is triggered
 * @param {Boolean} [options.startTabIndex] start index for tabindex
 * @param {Boolean} [options.progressRow] has to be enabled when datagrid is editable to show progress of save action
 * @param {String} [options.columnMinWidth] sets the minimal width of table columns
 * @param {String|Object} [options.contentContainer] the container which holds the datagrid; this options resizes the contentContainer for responsiveness
 * @param {Array} [options.showElementsSteps] Array which contains the steps for the Show-Elements-dropdown as integers
 * @param {String} [options.fullWidth] If true datagrid style will be full-width mode
 */
define(function() {

    &#x27;use strict&#x27;;

    /**
     *    Default values for options
     */
    var defaults = {
            autoRemoveHandling: true,
            editable: false,
            className: &#x27;datagridcontainer&#x27;,
            elementType: &#x27;table&#x27;,
            data: null,
            defaultMeasureUnit: &#x27;px&#x27;,
            excludeFields: [&#x27;id&#x27;],
            instance: &#x27;datagrid&#x27;,
            pagination: false,
            //fullWidth: false,
            paginationOptions: {
                pageSize: null,
                showPages: null
            },
            contentContainer: null,
            removeRow: true,
            selectItem: {
                type: null,      // checkbox, radio button
                width: &#x27;50px&#x27;    // numerous value
                //clickable: false   // defines if background is clickable TODO do not use until fixed
            },
            sortable: false,
            columns: [],
            url: null,
            appendTBody: true,   // add TBODY to table
            searchInstanceName: null, // at which search it should be listened to can be null|string|empty_string
            columnOptionsInstanceName: null, // at which search it should be listened to can be null|string|empty_string
            paginationTemplate: &#x27;&lt;%=translate(&quot;pagination.page&quot;)%&gt; &lt;strong&gt;&lt;%=i%&gt;&lt;/strong&gt; &lt;%=translate(&quot;pagination.of&quot;)%&gt; &lt;%=pages%&gt;&#x27;,
            fieldsData: null,
            validation: false, // TODO does not work for added rows
            validationDebug: false,
            addRowTop: false,
            progressRow: true,
            startTabIndex: 99999,
            columnMinWidth: &#x27;70px&#x27;,
            showElementsSteps: [10, 20, 50, 100, 500]
        },

        types = {
            DATE: &#x27;date&#x27;
        },

        constants = {
            fullWidthClass: &#x27;fullwidth&#x27;,
            // if datagrid is in fullwidth-mode (options.fullWidth is true)
            // this number gets subracted from the datagrids final width in the resize listener
            overflowIconSpacing: 30
        },

        namespace = &#x27;husky.datagrid.&#x27;,

    /* TRIGGERS EVENTS */

        /**
         * raised when item is deselected
         * @event husky.datagrid.item.deselect
         * @param {String} id of deselected item
         */
            ITEM_DESELECT = namespace + &#x27;item.deselect&#x27;,

        /**
         * raised when item is selected
         * @event husky.datagrid.item.select
         * @param {String} if of selected item
         */
            ITEM_SELECT = namespace + &#x27;item.select&#x27;,

        /**
         * raised when clicked on an item
         * @event husky.datagrid.item.click
         * @param {String} id of item that was clicked
         */
            ITEM_CLICK = namespace + &#x27;item.click&#x27;,

        /**
         * raised when husky.datagrid.items.get-selected is triggered
         * @event husky.datagrid.items.selected
         * @param {Array} ids of all items that have been clicked
         */
            ITEMS_SELECTED = namespace + &#x27;items.selected&#x27;,

        /**
         * raised when all items get deselected via the header checkbox
         * @event husky.datagrid.all.deselect
         */
            ALL_DESELECT = namespace + &#x27;all.deselect&#x27;,

        /**
         * raised when all items get deselected via the header checkbox
         * @event husky.datagrid.all.select
         * @param {Array} ids of all items that have been clicked
         */
            ALL_SELECT = namespace + &#x27;all.select&#x27;,

        /**
         * click - raised when clicked on the remove-row-icon
         * @event husky.datagrid.row.remove-click
         * @param {Object} event object of click
         * @param {String} id of item that was clicked for removal
         */
            ROW_REMOVE_CLICK = namespace + &#x27;row.remove-click&#x27;,

        /**
         * raised when row got removed
         * @event husky.datagrid.row.removed
         * @param {String} id of item that was removed
         */
            ROW_REMOVED = namespace + &#x27;row.removed&#x27;,

        /**
         * raised when the the current page changes
         * @event husky.datagrid.page.change
         */
            PAGE_CHANGE = namespace + &#x27;page.change&#x27;,

        /**
         * raised when the data is updated
         * @event husky.datagrid.updated
         */
            UPDATED = namespace + &#x27;updated&#x27;,

        /**
         * raised when husky.datagrid.data.get is triggered
         * @event husky.datagrid.data.provide
         */
            DATA_PROVIDE = namespace + &#x27;data.provide&#x27;,

        /**
         * raised when data is sorted
         * @event husky.datagrid.data.sort
         */
            DATA_SORT = namespace + &#x27;data.sort&#x27;,

        /**
         * raised when selection of items changes
         * @event husky.datagrid.number.selections
         */
            NUMBER_SELECTIONS = namespace + &#x27;number.selections&#x27;,

        /**
         * raised when data was saved
         * @event husky.datagrid.data.saved
         * @param {Object} data returned
         */
            DATA_SAVED = namespace + &#x27;data.saved&#x27;,

        /**
         * raised when save of data failed
         * @event husky.datagrid.data.save.failed
         * @param {String} text status
         * @param {String} error thrown
         *
         */
            DATA_SAVE_FAILED = namespace + &#x27;data.save.failed&#x27;,

        /**
         * raised when editable list is changed
         * @event husky.datagrid.data.save
         */
            DATA_CHANGED = namespace + &#x27;data.changed&#x27;,


    /* PROVIDED EVENTS */

        /**
         * used to trigger an update of the data
         * @event husky.datagrid.update
         */
            UPDATE = namespace + &#x27;update&#x27;,

        /**
         * used to filter data by search
         * @event husky.datagrid.data.filter
         * @param {String} searchField
         * @param {String} searchString
         */
            DATA_SEARCH = namespace + &#x27;data.search&#x27;,

        /**
         * used to filter data by updating an url parameter
         * @event husky.datagrid.url.update
         * @param {Object} url parameter : key
         */
            URL_UPDATE = namespace + &#x27;url.update&#x27;,

        /**
         * used to update the table width and its containers due to responsiveness
         * @event husky.datagrid.update.table
         */
            UPDATE_TABLE = namespace + &#x27;update.table&#x27;,

        /**
         * used to add a row
         * @event husky.datagrid.row.add
         * @param {String} id of the row to be removed
         */
            ROW_ADD = namespace + &#x27;row.add&#x27;,

        /**
         * used to remove a row
         * @event husky.datagrid.row.remove
         * @param {String} id of the row to be removed
         */
            ROW_REMOVE = namespace + &#x27;row.remove&#x27;,

        /**
         * triggers husky.datagrid.items.selected event, which returns all selected item ids
         * @event husky.datagrid.items.get-selected
         * @param  {Function} callback function receives array of selected items
         */
            ITEMS_GET_SELECTED = namespace + &#x27;items.get-selected&#x27;,

        /**
         * triggers husky.datagrid.data.provide
         * @event husky.datagrid.data.get
         */
            DATA_GET = namespace + &#x27;data.get&#x27;,

        /**
         * calculates the width of a text by creating a tablehead element and measure its width
         * @param text
         * @param classArray
         * @param isSortable
         */
            getTextWidth = function(text, classArray, isSortable) {

            var elWidth, el,
                sortIconWidth = 0,
                paddings = 20;
            // handle css classes
            if (!classArray) {
                classArray = [];
            }
            if (isSortable) {
                classArray.push(&#x27;is-sortable&#x27;);
                sortIconWidth = 20;
            }
            classArray.push(&#x27;is-selected&#x27;);

            el = this.sandbox.dom.createElement(&#x27;&lt;table style=&quot;width:auto&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&quot;&#x27; + classArray.join(&#x27;,&#x27;) + &#x27;&quot;&gt;&#x27; + text + &#x27;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;&#x27;);
            this.sandbox.dom.css(el, {
                &#x27;position&#x27;: &#x27;absolute&#x27;,
                &#x27;visibility&#x27;: &#x27;hidden&#x27;,
                &#x27;height&#x27;: &#x27;auto&#x27;,
                &#x27;width&#x27;: &#x27;auto&#x27;
            });
            this.sandbox.dom.append(&#x27;body&#x27;, el);

            // text width + paddings and sorting icon
            elWidth = this.sandbox.dom.width(el) + paddings + sortIconWidth;

            this.sandbox.dom.remove(el);

            return elWidth;
        };

    return {

        view: true,

        initialize: function() {
            this.sandbox.logger.log(&#x27;initialized datagrid&#x27;);

            // extend default options and set variables
            this.options = this.sandbox.util.extend(true, {}, defaults, this.options);
            this.name = this.options.name;
            this.dropdownInstanceName = &#x27;datagrid-pagination-dropdown&#x27;;
            this.data = null;
            this.allItemIds = [];
            this.selectedItemIds = [];
            this.rowStructure = [];
            this.elId = this.sandbox.dom.attr(this.$el, &#x27;id&#x27;);
            this.currentUrl = &#x27;&#x27;;

            if (!!this.options.contentContainer) {
                if (this.sandbox.dom.css(this.options.contentContainer, &#x27;max-width&#x27;) === &#x27;none&#x27;) {
                    this.originalMaxWidth = null;
                } else {
                    this.originalMaxWidth = this.getNumberAndUnit(this.sandbox.dom.css(this.options.contentContainer, &#x27;max-width&#x27;)).number;
                }
                this.contentMarginRight = this.getNumberAndUnit(this.sandbox.dom.css(this.options.contentContainer, &#x27;margin-right&#x27;)).number;
                this.contentPaddings = this.getNumberAndUnit(this.sandbox.dom.css(this.options.contentContainer, &#x27;padding-right&#x27;)).number;
                this.contentPaddings += this.getNumberAndUnit(this.sandbox.dom.css(this.options.contentContainer, &#x27;padding-left&#x27;)).number;
            } else {
                this.contentMarginRight = 0;
                this.contentPaddings = 0;
            }

            this.domId = 0;

            this.bottomTabIndex = this.options.startTabIndex || 49999;
            this.topTabIndex = this.options.startTabIndex || 50000;

            this.errorInRow = [];

            this.sort = {
                ascClass: &#x27;icon-arrow-up&#x27;,
                descClass: &#x27;icon-arrow-down&#x27;,
                additionalClasses: &#x27; m-left-5 small-font&#x27;
            };

            // append datagrid to html element
            this.$originalElement = this.sandbox.dom.$(this.options.el);
            this.$element = this.sandbox.dom.$(&#x27;&lt;div class=&quot;husky-datagrid&quot;/&gt;&#x27;);
            this.$originalElement.append(this.$element);

            this.getData();

            // Should only be be called once
            this.bindCustomEvents();
        },

        /**
         * Gets the data either via the url or the array
         */
        getData: function() {
            var fieldsData, url;

            if (!!this.options.url) {
                url = this.options.url;

                // parse fields data
                if (this.options.fieldsData) {
                    fieldsData = this.parseFieldsData(this.options.fieldsData);
                    url += &#x27;&amp;fields=&#x27; + fieldsData.urlFields;
                    this.options.columns = fieldsData.columns;
                }

                this.sandbox.logger.log(&#x27;load data from url&#x27;);
                this.load({ url: url});

            } else if (!!this.options.data.items) {

                this.sandbox.logger.log(&#x27;load data from array&#x27;);
                this.data = this.options.data;

                this.prepare()
                    .appendPagination()
                    .render();
            }
        },

        /**
         * parses fields data retrieved from api
         * @param fields
         * @returns {{columns: Array, urlFields: string}}
         */
        parseFieldsData: function(fields) {
            var data = [],
                urlfields = [],
                fieldsCount = 0,
                tmp;

            this.sandbox.util.foreach(fields, function(field) {

                tmp = {};

                if (field.disabled !== &#x27;true&#x27; &amp;&amp; field.disabled !== true) {

                    // data
                    for (var key in field) {
                        if (key === &#x27;translation&#x27;) {
                            tmp.content = this.sandbox.translate(field.translation);
                        } else if (key === &#x27;id&#x27;) {
                            tmp.attribute = field.id;
                        } else {
                            tmp[key] = field[key];
                        }
                    }

                    data.push(tmp);
                    urlfields.push(field.id);

                } else if (field.id === &#x27;id&#x27;) {
                    urlfields.push(field.id);
                }

                fieldsCount++;

            }.bind(this));
            return {
                columns: data,
                urlFields: urlfields.join(&#x27;,&#x27;)
            };
        },

        /**
         * Loads contents via ajax
         * @param params url
         */
        load: function(params) {
            this.currentUrl = params.url;
            this.sandbox.util.load(this.getUrl(params), params.data)
                .then(function(response) {
                    this.initRender(response, params);
                }.bind(this))
                .fail(function(status, error) {
                    this.sandbox.logger.error(status, error);
                }.bind(this));
        },


        /**
         * Initializes the rendering of the datagrid
         */
        initRender: function(response, params) {

            this.data = {};
            this.data.links = response._links;
            this.data.embedded = response._embedded;
            this.data.total = response.total;
            this.data.numberOfAll = response.numberOfAll;
            this.data.page = response.page;
            this.data.pages = response.pages;
            this.data.pageSize = response.pageSize || this.options.paginationOptions.pageSize;
            this.data.pageDisplay = this.options.paginationOptions.showPages;

            this.prepare()
                .appendPagination()
                .render();

            this.setHeaderClasses();

            if (!!params &amp;&amp; typeof params.success === &#x27;function&#x27;) {
                params.success(response);
            }

            this.windowResizeListener();
        },

        /**
         * Returns url with page size and page param at the end
         * @param params
         * @returns {string}
         */
        getUrl: function(params) {

            if (!!this.data &amp;&amp; !!this.data.links) {
                return params.url;
            }

            var delimiter = &#x27;?&#x27;, url = params.url;

            if (!!this.options.pagination &amp;&amp; !!this.options.paginationOptions.pageSize) {

                if (params.url.indexOf(&#x27;?&#x27;) !== -1) {
                    delimiter = &#x27;&amp;&#x27;;
                }

                url = params.url + delimiter + &#x27;pageSize=&#x27; + this.options.paginationOptions.pageSize;
                if (params.page &gt; 1) {
                    url += &#x27;&amp;page=&#x27; + params.page;
                }
            }

            return url;
        },

        /**
         * Prepares the structure of the datagrid (list, table)
         * @returns {*}
         */
        prepare: function() {
            this.$element.empty();

            if (this.options.elementType === &#x27;list&#x27;) {
                // TODO this.$element = this.prepareList();
                this.sandbox.logger.log(&quot;list is not yet implemented!&quot;);
            } else {
                this.$tableContainer = this.sandbox.dom.createElement(&#x27;&lt;div class=&quot;table-container&quot;/&gt;&#x27;);
                this.sandbox.dom.append(this.$element, this.$tableContainer);
                this.sandbox.dom.append(this.$tableContainer, this.prepareTable());
            }

            return this;
        },

        /**
         * Perapres the structure of the datagrid when element type is table
         * @returns {table} returns table element
         */
        prepareTable: function() {
            var $table, $thead, $tbody, tblClasses;

            this.$table = $table = this.sandbox.dom.createElement(&#x27;&lt;table&#x27; + (!!this.options.validationDebug ? &#x27;data-debug=&quot;true&quot;&#x27; : &#x27;&#x27; ) + &#x27;/&gt;&#x27;);

            if (!!this.data.head || !!this.options.columns) {
                $thead = this.sandbox.dom.createElement(&#x27;&lt;thead/&gt;&#x27;);
                $thead.append(this.prepareTableHead());
                $table.append($thead);
            }

            if (!!this.data.embedded) {
                if (!!this.options.appendTBody) {
                    $tbody = this.sandbox.dom.$(&#x27;&lt;tbody/&gt;&#x27;);
                }
                this.sandbox.dom.append($tbody, this.prepareTableRows());
                this.sandbox.dom.append($table, $tbody);
            }

            // set html classes
            tblClasses = [];
            tblClasses.push((!!this.options.className &amp;&amp; this.options.className !== &#x27;table&#x27;) ? &#x27;table &#x27; + this.options.className : &#x27;table&#x27;);

            // when list should not have the hover effect for whole rows do not set the is-selectable class
            if (!this.options.editable) {
                tblClasses.push((this.options.selectItem &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) ? &#x27;is-selectable&#x27; : &#x27;&#x27;);
            }

            $table.addClass(tblClasses.join(&#x27; &#x27;));

            return $table;
        },

        /**
         * Prepares table head
         * @returns {string} returns table head
         */

        prepareTableHead: function() {
            var tblColumns, tblCellClass, headData, widthValues, checkboxValues, dataAttribute, isSortable,
                tblColumnStyle, minWidth;

            tblColumns = [];
            headData = this.options.columns || this.data.head;

            // add a checkbox to head row
            if (!!this.options.selectItem &amp;&amp; this.options.selectItem.type) {

                // default values
                if (this.options.selectItem.width) {
                    checkboxValues = this.getNumberAndUnit(this.options.selectItem.width);
                }

                minWidth = checkboxValues.number + checkboxValues.unit;

                tblColumns.push(
                    &#x27;&lt;th class=&quot;select-all&quot; &#x27;, &#x27;style=&quot;width:&#x27; + minWidth + &#x27;;max-width:&#x27; + minWidth + &#x27;;min-width:&#x27; + minWidth + &#x27;;&quot;&#x27;, &#x27; &gt;&#x27;);

                if (this.options.selectItem.type === &#x27;checkbox&#x27;) {
                    tblColumns.push(this.templates.checkbox({ id: &#x27;select-all&#x27; }));
                }

                tblColumns.push(&#x27;&lt;/th&gt;&#x27;);
            }

            this.rowStructure = [];

            // value used for correct tabindex when row added at top of table
            this.tabIndexParam = 1;

            headData.forEach(function(column) {

                isSortable = false;

                if (!!this.data.links &amp;&amp; !!this.data.links.sortable) {

                    //is column sortable - check with received sort-links
                    this.sandbox.util.each(this.data.links.sortable, function(index) {
                        if (index === column.attribute) {
                            isSortable = true;
                            return false;
                        }
                    }.bind(this));
                }

                // calculate width
                tblColumnStyle = [];
                if (column.width) {
                    minWidth = column.width;
                } else if (column.minWidth) {
                    minWidth = column.minWidth;
                } else {
                    minWidth = getTextWidth.call(this, column.content, [], isSortable);
                    minWidth = (minWidth &gt; this.getNumberAndUnit(this.options.columnMinWidth).number) ? minWidth + &#x27;px&#x27; : this.options.columnMinWidth;

                }
                tblColumnStyle.push(&#x27;min-width:&#x27; + minWidth);
                column.minWidth = minWidth;

                // get width and measureunit
                if (!!column.width) {
                    widthValues = this.getNumberAndUnit(column.width);
                    tblColumnStyle.push(&#x27;max-width:&#x27; + widthValues.number + widthValues.unit);
                    tblColumnStyle.push(&#x27;width:&#x27; + widthValues.number + widthValues.unit);
                }

                // add to row structure when valid entry
                if (column.attribute !== undefined) {
                    this.rowStructure.push({
                        attribute: column.attribute,
                        editable: column.editable,
                        validation: column.validation,
                        type: column.type
                    });

                    if (!!column.editable) {
                        this.tabIndexParam++;
                    }
                }


                // add html to table header cell if sortable
                if (!!isSortable) {
                    dataAttribute = &#x27; data-attribute=&quot;&#x27; + column.attribute + &#x27;&quot;&#x27;;
                    tblCellClass = ((!!column.class) ? &#x27; class=&quot;&#x27; + column.class + &#x27; is-sortable&quot;&#x27; : &#x27; class=&quot;is-sortable&quot;&#x27;);
                    tblColumns.push(&#x27;&lt;th&#x27; + tblCellClass + &#x27; style=&quot;&#x27; + tblColumnStyle.join(&#x27;;&#x27;) + &#x27;&quot; &#x27; + dataAttribute + &#x27;&gt;&#x27; + column.content + &#x27;&lt;span&gt;&lt;/span&gt;&lt;/th&gt;&#x27;);
                } else {
                    tblCellClass = ((!!column.class) ? &#x27; class=&quot;&#x27; + column.class + &#x27;&quot;&#x27; : &#x27;&#x27;);
                    tblColumns.push(&#x27;&lt;th&#x27; + tblCellClass + &#x27; style=&quot;&#x27; + tblColumnStyle.join(&#x27;;&#x27;) + &#x27;&quot; &gt;&#x27; + column.content + &#x27;&lt;/th&gt;&#x27;);
                }

            }.bind(this));

            // remove-row entry
            if (this.options.removeRow || this.options.progressRow) {
                tblColumns.push(&#x27;&lt;th style=&quot;width:30px;&quot;/&gt;&#x27;);
            }

            return &#x27;&lt;tr&gt;&#x27; + tblColumns.join(&#x27;&#x27;) + &#x27;&lt;/tr&gt;&#x27;;
        },

        /**
         * returns number and unit
         * @param numberUnit
         * @returns {{number: Number, unit: *}}
         */
        getNumberAndUnit: function(numberUnit) {
            numberUnit = String(numberUnit);
            var regex = numberUnit.match(/(\d+)\s*(.*)/);
            // no unit , set default
            if (!regex[2]) {
                regex[2] = this.options.defaultMeasureUnit;
            }
            return {number: parseInt(regex[1], 10), unit: regex[2]};
        },

        /**
         * Itterates over all items and prepares the rows
         * @returns {string} returns a string of all rows
         */
        prepareTableRows: function() {
            var tblRows;

            tblRows = [];
            this.allItemIds = [];

            if (!!this.data.embedded) {
                this.data.embedded.forEach(function(row) {
                    tblRows.push(this.prepareTableRow(row, false));
                }.bind(this));
            }

            return tblRows.join(&#x27;&#x27;);
        },

        /**
         * Returns a table row including values and data attributes
         * @param row
         * @param triggeredByAddRow
         * @returns string table row
         */
        prepareTableRow: function(row, triggeredByAddRow) {

            if (!!(this.options.template &amp;&amp; this.options.template.row)) {

                return this.sandbox.template.parse(this.options.template.row, row);

            } else {

                var radioPrefix, key, i;
                this.tblColumns = [];
                this.tblRowAttributes = &#x27; data-dom-id=&quot;dom-&#x27; + this.options.instance + &#x27;-&#x27; + this.domId + &#x27;&quot;&#x27;;
                this.domId++;

                // special treatment for id
                if (!!row.id) {
                    this.tblRowAttributes += &#x27; data-id=&quot;&#x27; + row.id + &#x27;&quot;&#x27;;
                }

                if (!!this.options.className &amp;&amp; this.options.className !== &#x27;&#x27;) {
                    radioPrefix = &#x27;-&#x27; + this.options.className;
                } else {
                    radioPrefix = &#x27;&#x27;;
                }

                !!row.id &amp;&amp; this.allItemIds.push(parseInt(row.id, 10));

                // add a checkbox to each row
                if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) {
                    this.tblColumns.push(&#x27;&lt;td&gt;&#x27;, this.templates.checkbox(), &#x27;&lt;/td&gt;&#x27;);

                    // add a radio to each row
                } else if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;radio&#x27;) {
                    this.tblColumns.push(&#x27;&lt;td&gt;&#x27;, this.templates.radio({
                        name: &#x27;husky-radio&#x27; + radioPrefix
                    }), &#x27;&lt;/td&gt;&#x27;);
                }

                // when row structure contains more elements than the id then use the structure to set values
                if (this.rowStructure.length) {

                    if (!!triggeredByAddRow &amp;&amp; !!this.options.addRowTop) {
                        this.bottomTabIndex -= (this.tabIndexParam + 1);
                    }

                    this.rowStructure.forEach(function(key, index) {
                        key.editable = key.editable || false;
                        this.createRowCell(key.attribute, row[key.attribute], key.type, key.editable, key.validation, triggeredByAddRow, index);
                    }.bind(this));

                } else {
                    i = 0;
                    for (key in row) {
                        if (row.hasOwnProperty(key)) {
                            this.createRowCell(key, row[key], null, false, null, triggeredByAddRow, i);
                            i++;
                        }
                    }
                }

                if (!!this.options.removeRow) {
                    this.tblColumns.push(&#x27;&lt;td class=&quot;remove-row&quot;&gt;&#x27;, this.templates.removeRow(), &#x27;&lt;/td&gt;&#x27;);
                } else if (!!this.options.progressRow) {
                    this.tblColumns.push(&#x27;&lt;td class=&quot;progress-row&quot;&gt;&#x27;, this.templates.progressRow(), &#x27;&lt;/td&gt;&#x27;);
                }

                return &#x27;&lt;tr&#x27; + this.tblRowAttributes + &#x27;&gt;&#x27; + this.tblColumns.join(&#x27;&#x27;) + &#x27;&lt;/tr&gt;&#x27;;
            }
        },

        /**
         * Sets the value of row cell and the data-id attribute for the row
         * @param key attribute name
         * @param value attribute value
         * @param type {String} The type of the cell. Used to call a function to manipulate the content
         * @param editable flag whether field is editable or not
         * @param validation information for field
         * @param triggeredByAddRow triggered trough add row
         * @param index
         */
        createRowCell: function(key, value, type, editable, validation, triggeredByAddRow, index) {
            var tblCellClasses,
                tblCellContent,
                tblCellStyle,
                tblCellClass,
                k,
                validationAttr = &#x27;&#x27;;

            if (!value) {
                value = &#x27;&#x27;;
            }

            if (this.options.excludeFields.indexOf(key) &lt; 0) {
                tblCellClasses = [];
                tblCellContent = (!!value.thumb) ? &#x27;&lt;img alt=&quot;&#x27; + (value.alt || &#x27;&#x27;) + &#x27;&quot; src=&quot;&#x27; + value.thumb + &#x27;&quot;/&gt;&#x27; : value;

                // prepare table cell classes
                !!value.class &amp;&amp; tblCellClasses.push(value.class);
                !!value.thumb &amp;&amp; tblCellClasses.push(&#x27;thumb&#x27;);

                tblCellClass = (!!tblCellClasses.length) ? &#x27;class=&quot;&#x27; + tblCellClasses.join(&#x27; &#x27;) + &#x27;&quot;&#x27; : &#x27;&#x27;;

                if (!!this.options.validation &amp;&amp; !!validation) {
                    for (k in validation) {
                        validationAttr += [&#x27;data-validation-&#x27;, k, &#x27;=&quot;&#x27;, validation[k], &#x27;&quot; &#x27;].join(&#x27;&#x27;);
                    }
                }

                tblCellStyle = &#x27;style=&quot;max-width:&#x27; + this.options.columns[index].minWidth + &#x27;&quot;&#x27;;

                // call the type manipulate to manipulate the content of the cell
                if (!!type) {
                    tblCellContent = this.manipulateCellContent(tblCellContent, type);
                }

                if (!!editable) {

                    if (!!triggeredByAddRow) {

                        // differentiate for tab index
                        if (!!this.options.addRowTop) {
                            this.tblColumns.push(&#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &gt;&lt;span class=&quot;editable&quot; style=&quot;display: none&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/span&gt;&lt;input type=&quot;text&quot; class=&quot;form-element editable-content&quot; tabindex=&quot;&#x27; + this.bottomTabIndex + &#x27;&quot; value=&quot;&#x27; + tblCellContent + &#x27;&quot;  &#x27; + validationAttr + &#x27;/&gt;&lt;/td&gt;&#x27;);
                            this.bottomTabIndex++;
                        } else {
                            this.tblColumns.push(&#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &gt;&lt;span class=&quot;editable&quot; style=&quot;display: none&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/span&gt;&lt;input type=&quot;text&quot; class=&quot;form-element editable-content&quot; tabindex=&quot;&#x27; + this.topTabIndex + &#x27;&quot; value=&quot;&#x27; + tblCellContent + &#x27;&quot;  &#x27; + validationAttr + &#x27;/&gt;&lt;/td&gt;&#x27;);
                            this.topTabIndex++;
                        }

                    } else {
                        this.tblColumns.push(&#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &gt;&lt;span class=&quot;editable&quot;&gt;&#x27; + tblCellContent + &#x27;&lt;/span&gt;&lt;input type=&quot;text&quot; class=&quot;form-element editable-content hidden&quot; value=&quot;&#x27; + tblCellContent + &#x27;&quot; tabindex=&quot;&#x27; + this.topTabIndex + &#x27;&quot; &#x27; + validationAttr + &#x27;/&gt;&lt;/td&gt;&#x27;);
                        this.topTabIndex++;

                    }

                } else {
                    this.tblColumns.push(&#x27;&lt;td data-field=&quot;&#x27; + key + &#x27;&quot; &#x27; + tblCellClass + &#x27; &#x27; + tblCellStyle + &#x27;&gt;&#x27; + tblCellContent + &#x27;&lt;/td&gt;&#x27;);
                }
            } else {
                this.tblRowAttributes += &#x27; data-&#x27; + key + &#x27;=&quot;&#x27; + value + &#x27;&quot;&#x27;;
            }
        },

        /**
         * Manipulates the content of a cell with a process realted to the columns type
         * @param content {String} the content of the cell
         * @param type {String} the columns type
         * @returns {String} the manipualted content
         */
        manipulateCellContent: function(content, type) {
            if (type === types.DATE) {
                content = this.parseDate(content);
            }
            return content;
        },

        /**
         * Brings a date into the right format
         * @param date {String} the date to parse
         * @returns {String}
         */
        parseDate: function(date) {
            var parsedDate = this.sandbox.date.format(date);
            if (parsedDate !== null) {
                return parsedDate;
            }
            return date;
        },

        /**
         * Resets the arrays for selected items
         */
        resetItemSelection: function() {
            this.allItemIds = [];
            this.selectedItemIds = [];
        },

        /**
         * Selectes or deselects the clicked item
         * @param event
         */
        selectItem: function(event) {

            event.stopPropagation();

            // Todo review handling of events for new rows in datagrid (itemId empty?)

            var $element, itemId, oldSelectionId, parentTr;

            $element = this.sandbox.dom.$(event.currentTarget);

            if (!$element.is(&#x27;input&#x27;)) {
                $element = this.sandbox.dom.find(&#x27;input&#x27;, this.sandbox.dom.parent($element));
            }

            parentTr = this.sandbox.dom.parents($element, &#x27;tr&#x27;);
            itemId = this.sandbox.dom.data(parentTr, &#x27;id&#x27;);

            if ($element.attr(&#x27;type&#x27;) === &#x27;checkbox&#x27;) {

                if (this.sandbox.dom.prop($element, &#x27;checked&#x27;) === false) {
                    $element
                        .removeClass(&#x27;is-selected&#x27;)
                        .prop(&#x27;checked&#x27;, false);

                    // uncheck &#x27;Select All&#x27;-checkbox
                    $(&#x27;th.select-all&#x27;)
                        .find(&#x27;input[type=&quot;checkbox&quot;]&#x27;)
                        .prop(&#x27;checked&#x27;, false);

                    this.selectedItemIds.splice(this.selectedItemIds.indexOf(itemId), 1);
                    this.sandbox.emit(ITEM_DESELECT, itemId);
                } else {
                    $element
                        .addClass(&#x27;is-selected&#x27;)
                        .prop(&#x27;checked&#x27;, true);

                    if (!!itemId) {
                        this.selectedItemIds.push(itemId);
                        this.sandbox.emit(ITEM_SELECT, itemId);
                    } else {
                        this.sandbox.emit(ITEM_SELECT, event);
                    }
                }

                this.sandbox.emit(NUMBER_SELECTIONS, this.getIdsOfSelectedRows().length);

            } else if ($element.attr(&#x27;type&#x27;) === &#x27;radio&#x27;) {

                oldSelectionId = this.selectedItemIds.pop();

                if (!!oldSelectionId &amp;&amp; oldSelectionId &gt; -1) {
                    this.sandbox.dom.$(&#x27;tr[data-id=&quot;&#x27; + oldSelectionId + &#x27;&quot;]&#x27;).find(&#x27;input[type=&quot;radio&quot;]&#x27;).removeClass(&#x27;is-selected&#x27;).prop(&#x27;checked&#x27;, false);
                    this.sandbox.emit(ITEM_DESELECT, oldSelectionId);
                }

                $element.addClass(&#x27;is-selected&#x27;).prop(&#x27;checked&#x27;, true);

                if (!!itemId) {
                    this.selectedItemIds.push(itemId);
                    this.sandbox.emit(ITEM_SELECT, itemId);
                } else {
                    this.sandbox.emit(ITEM_SELECT, event);
                }
                this.sandbox.emit(NUMBER_SELECTIONS, this.selectedItemIds.length);
            }

        },

        /**
         * Selects or deselect all available items of the list
         * @param event
         */
        selectAllItems: function(event) {

            event.stopPropagation();

            var $headCheckbox = this.sandbox.dom.find(&#x27;th input[type=&quot;checkbox&quot;]&#x27;, this.$el)[0],
                $checkboxes = this.sandbox.dom.find(&#x27;input[type=&quot;checkbox&quot;]&#x27;, this.$el),
                selectedElements,
                tmp;

            if (this.sandbox.dom.prop($headCheckbox, &#x27;checked&#x27;) === false) {
                this.sandbox.dom.prop($checkboxes, &#x27;checked&#x27;, false);
                this.sandbox.dom.removeClass($checkboxes, &#x27;is-selected&#x27;);
                this.sandbox.emit(ALL_DESELECT);
            } else {
                this.sandbox.dom.prop($checkboxes, &#x27;checked&#x27;, true);
                this.sandbox.dom.addClass($checkboxes, &#x27;is-selected&#x27;);
                this.sandbox.emit(ALL_SELECT, this.getIdsOfSelectedRows());
            }

            tmp = this.sandbox.dom.find(&#x27;input[type=&quot;checkbox&quot;]:checked&#x27;, this.$el).length - 1;
            selectedElements = tmp &gt; 0 ? tmp : 0;

            this.sandbox.emit(NUMBER_SELECTIONS, selectedElements);
        },


        /**
         * Returns an array with the ids of the selected rows
         */
        getIdsOfSelectedRows: function() {
            var $checkboxes = this.sandbox.dom.find(&#x27;input[type=checkbox]:checked&#x27;, this.$el),
                ids = [],
                id,
                $tr;

            this.sandbox.util.each($checkboxes, function(index, $checkbox) {
                $tr = this.sandbox.dom.closest($checkbox, &#x27;tr&#x27;);
                id = this.sandbox.dom.data($tr, &#x27;id&#x27;);
                if (!!id) {
                    ids.push(id);
                }

            }.bind(this));

            return ids;
        },

        /**
         * Adds a row to the datagrid
         * @param row
         */
        addRow: function(row) {
            var $table, $row, $firstInputField, $checkbox;
            // check for other element types when implemented
            $table = this.$element.find(&#x27;table&#x27;);
            $row = this.sandbox.dom.$(this.prepareTableRow(row, true));

            // when unsaved new row exists - save it
            this.prepareSave();

            // prepend or append row
            if (!!this.options.addRowTop) {
                this.sandbox.dom.prepend($table, $row);
            } else {
                this.sandbox.dom.append($table, $row);
            }

            $firstInputField = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $row)[0];
            this.sandbox.dom.focus($firstInputField);

            if (!!this.options.editable) {
                this.lastFocusedRow = this.getInputValuesOfRow($row);
            }

            // TODO fix validation for new rows
//            if (!!this.options.validation) {
            // add new row to validation context and add contraints to element
//                $editableFields = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $row);

//                this.sandbox.util.foreach($editableFields, function($el, i) {
//                    this.sandbox.form.addField(&#x27;#&#x27; + this.elId, $el);

//                    validation = this.options.columns[i].validation;
//                    for (var key in validation) {
//                        this.sandbox.form.addConstraint(&#x27;#&#x27; + this.elId, $el, key, {key: validation[key]});
//                    }
//                }.bind(this));

//            }

            // if allchecked then disable top checkbox after adding new row
            if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) {
                $checkbox = this.sandbox.dom.find(&#x27;#select-all&#x27;, this.$el);
                if (this.sandbox.dom.hasClass($checkbox, &#x27;is-selected&#x27;)) {
                    this.sandbox.dom.prop($checkbox, &#x27;checked&#x27;, false);
                    this.sandbox.dom.removeClass($checkbox, &#x27;is-selected&#x27;);
                }
            }
        },

        /**
         * Prepares for removing a row
         * Raises the husky.datagrid.row.remove-click event when auto remove handling is not set to true
         * @param event
         */
        prepareRemoveRow: function(event) {
            if (!!this.options.autoRemoveHandling) {
                this.removeRow(event);
            } else {
                var $tblRow, id;

                $tblRow = this.sandbox.dom.$(event.currentTarget).parent().parent();
                id = $tblRow.data(&#x27;id&#x27;);

                if (!!id) {
                    this.sandbox.emit(ROW_REMOVE_CLICK, event, id);
                } else {
                    this.sandbox.emit(ROW_REMOVE_CLICK, event, $tblRow);
                }
            }
        },

        /**
         * Removes a row from the datagrid
         * Raises husky.datagrid.row.removed event
         * @param event
         */
        removeRow: function(event) {

            var $element, $tblRow, id, $editableElements, $checkboxes;

            if (typeof event === &#x27;object&#x27;) {
                $element = this.sandbox.dom.$(event.currentTarget);
                $tblRow = this.sandbox.dom.closest($element, &#x27;tr&#x27;)[0];
                id = this.sandbox.dom.data($tblRow, &#x27;id&#x27;);
            } else {
                id = event;
                $tblRow = this.sandbox.dom.find(&#x27;tr[data-id=&quot;&#x27; + id + &#x27;&quot;]&#x27;)[0];
            }

            // remove row elements from validation
            if (!!this.options.validation) {
                $editableElements = this.sandbox.dom.find(&#x27;.editable&#x27;, $tblRow);
                this.sandbox.util.each($editableElements, function(index, $element) {
                    this.sandbox.form.removeField(&#x27;#&#x27; + this.elId, $element);
                }.bind(this));
            }

            this.sandbox.emit(ROW_REMOVED, event);
            this.sandbox.dom.remove($tblRow);

            // when last table row was removed, uncheck thead checkbox if exists
            $checkboxes = this.sandbox.dom.find(&#x27;input[type=checkbox]&#x27;, this.$el);
            if ($checkboxes.length === 1) {
                this.sandbox.dom.removeClass(&#x27;is-selected&#x27;, $checkboxes[0]);
                this.sandbox.dom.prop($checkboxes[0], &#x27;checked&#x27;, false);
            }

        },

        // TODO: create pagination module
        /**
         * Appends pagination when option is set
         * @returns {*}
         */
        appendPagination: function() {

            if (this.options.pagination &amp;&amp; !!this.data.links) {
                this.initPaginationIds();
                this.$element.append(this.preparePagination());
                this.preparePaginationDropdown();
                this.prepareShowElementsDropdown();
            }
            return this;
        },

        /**
         * inits the dom ids needed for the pagination
         */
        initPaginationIds: function() {
            this.pagination = {
                prevId: this.options.instance + &#x27;-prev&#x27;,
                nextId: this.options.instance + &#x27;-next&#x27;,
                dropdownId: this.options.instance + &#x27;-pagination-dropdown&#x27;,
                showElementsId: this.options.instance + &#x27;-show-elements&#x27;
            };
        },

        /**
         * Delegates the rendering of the pagination when pagination is needed
         * @returns {*}
         */
        preparePagination: function() {
            var $pagination,
                $paginationWrapper,
                $showElements,
                paginationLabel;


            $paginationWrapper = this.sandbox.dom.$(&#x27;&lt;div/&gt;&#x27;);
            $paginationWrapper.addClass(&#x27;pagination-wrapper m-top-20 grid-row small-font&#x27;);

            // if first defined step is bigger than the number of all elements don&#x27;t display show-elements dropdown
            if (this.data.numberOfAll &gt; this.options.showElementsSteps[0]) {
                $showElements = this.sandbox.dom.$(this.templates.showElements.call(this, this.pagination.showElementsId));
                $paginationWrapper.append($showElements);
            }

            if (!!this.options.pagination &amp;&amp; parseInt(this.data.pages, 10) &gt; 1) {
                $pagination = this.sandbox.dom.$(&#x27;&lt;div/&gt;&#x27;);
                $pagination.addClass(&#x27;pagination&#x27;);

                $paginationWrapper.append($pagination);

                paginationLabel = this.renderPaginationRow(this.data.page, this.data.pages);

                $pagination.append(&#x27;&lt;div id=&quot;&#x27; + this.pagination.nextId + &#x27;&quot; class=&quot;pagination-prev pull-right pointer&quot;&gt;&lt;/div&gt;&#x27;);
                $pagination.append(&#x27;&lt;div id=&quot;&#x27; + this.pagination.dropdownId + &#x27;&quot; class=&quot;pagination-main pull-right pointer&quot;&gt;&lt;span class=&quot;inline-block&quot;&gt;&#x27; + paginationLabel + &#x27;&lt;/span&gt;&lt;span class=&quot;dropdown-toggle inline-block&quot;&gt;&lt;/span&gt;&lt;/div&gt;&#x27;);
                $pagination.append(&#x27;&lt;div id=&quot;&#x27; + this.pagination.prevId + &#x27;&quot; class=&quot;pagination-next pull-right pointer&quot;&gt;&lt;/div&gt;&#x27;);
            }

            return $paginationWrapper;
        },


        /**
         * Renders template for one row in the pagination
         * @param i current page number
         * @param pages total number of pages
         */
        renderPaginationRow: function(i, pages) {
            var defaults = {
                translate: this.sandbox.translate,
                i: i,
                pages: pages
            };

            return this.sandbox.util.template(this.options.paginationTemplate, defaults);
        },

        /**
         * Prepares and initializes the dropdown used for the pagination
         */
        preparePaginationDropdown: function() {

            var data = [], i, name;

            for (i = 1; i &lt;= this.data.pages; i++) {
                name = this.renderPaginationRow(i, this.data.pages);
                data.push({id: i, name: name});
            }

            this.sandbox.start([
                {
                    name: &#x27;dropdown@husky&#x27;,
                    options: {
                        el: this.sandbox.dom.find(&#x27;#&#x27; + this.pagination.dropdownId, this.$el),
                        setParentDropDown: true,
                        instanceName: this.dropdownInstanceName,
                        alignment: &#x27;right&#x27;,
                        data: data
                    }
                }
            ]);
        },

        /**
         * Prepares and initializes the dropdown for showing elements
         */
        prepareShowElementsDropdown: function() {
            var i, length, data = [];

            for(i = -1, length = this.options.showElementsSteps.length; ++i &lt; length;) {
                if (this.options.showElementsSteps[i] &gt; this.data.numberOfAll) {
                    break;
                }
                data.push({
                    id: this.options.showElementsSteps[i],
                    name: &#x27;&lt;strong&gt;&#x27;+ this.options.showElementsSteps[i] +&#x27;&lt;/strong&gt; &#x27; + this.sandbox.translate(&#x27;pagination.elements-per-page&#x27;)
                });
            }

            data.push({divider: true});
            data.push({
               id: 0,
               name: this.sandbox.translate(&#x27;pagination.show-all-elements&#x27;)
            });

            this.sandbox.start([
                {
                    name: &#x27;dropdown@husky&#x27;,
                    options: {
                        el: this.sandbox.dom.find(&#x27;#&#x27; + this.pagination.showElementsId, this.$el),
                        setParentDropDown: true,
                        instanceName: this.dropdownInstanceName + &#x27;-show&#x27;,
                        alignment: &#x27;left&#x27;,
                        data: data
                    }
                }
            ]);
        },

        /**
         * Called when the current page should change
         * Emits husky.datagrid.updated event on success
         * @param uri
         * @param event
         */
        changePage: function(uri, event) {
            var url, template;

            // when a valid uri is passed to this function - load from the uri
            if (!!uri) {
                if (!!event) {
                    event.preventDefault();
                }
                url = uri;

                // determine wether the page number received via the event from the dropdown is valid
            } else if (!!event.id &amp;&amp; event.id &gt; 0 &amp;&amp; event.id &lt;= this.data.pages) {
                template = this.sandbox.uritemplate.parse(this.data.links.pagination);
                url = this.sandbox.uritemplate.expand(template, {page: event.id, pageSize: this.data.pageSize});

                // invalid - whether page number nor uri are valid
            } else {
                this.sandbox.logger.log(&quot;invalid page number or reached start/end!&quot;);
                return;
            }

            this.sandbox.emit(PAGE_CHANGE, url);
            this.addLoader();
            this.load({url: url,
                success: function() {
                    this.removeLoader();
                    this.sandbox.emit(UPDATED, &#x27;updated page&#x27;);
                }.bind(this)});
        },

        resetSortingOptions: function() {
            this.sort.attribute = null;
            this.sort.direction = null;
        },

        bindDOMEvents: function() {

            // remove all events - prevents multiple events
            this.sandbox.dom.unbind(this.sandbox.dom.find(&#x27;*&#x27;, this.$el));
            this.sandbox.dom.unbind(this.$el);
            this.sandbox.dom.unbind(window, &#x27;click&#x27;);

            if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) {
                this.$element.on(&#x27;click&#x27;, &#x27;tbody &gt; tr input[type=&quot;checkbox&quot;]&#x27;, this.selectItem.bind(this));
                this.$element.on(&#x27;click&#x27;, &#x27;th.select-all&#x27;, this.selectAllItems.bind(this));
            } else if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;radio&#x27;) {
                this.$element.on(&#x27;click&#x27;, &#x27;tbody &gt; tr input[type=&quot;radio&quot;]&#x27;, this.selectItem.bind(this));
            }

            this.$element.on(&#x27;click&#x27;, &#x27;tbody &gt; tr&#x27;, function(event) {
                if (!this.sandbox.dom.$(event.target).is(&#x27;input&#x27;) &amp;&amp; !this.sandbox.dom.$(event.target).is(&#x27;span.icon-remove&#x27;)) {
                    var id = this.sandbox.dom.$(event.currentTarget).data(&#x27;id&#x27;);

                    if (!!id) {
                        this.sandbox.emit(ITEM_CLICK, id);
                    } else {
                        this.sandbox.emit(ITEM_CLICK, event);
                    }
                }
            }.bind(this));

            if (this.options.pagination) {

                // next page
                this.$element.on(&#x27;click&#x27;, &#x27;#&#x27; + this.pagination.nextId, this.changePage.bind(this, this.data.links.next));

                // previous page
                this.$element.on(&#x27;click&#x27;, &#x27;#&#x27; + this.pagination.prevId, this.changePage.bind(this, this.data.links.prev));
            }

            if (this.options.removeRow) {
                this.$element.on(&#x27;click&#x27;, &#x27;.remove-row &gt; span&#x27;, this.prepareRemoveRow.bind(this));
            }

            if (this.options.sortable) {
                this.sandbox.dom.on(this.$el, &#x27;click&#x27;, this.changeSorting.bind(this), &#x27;thead th[data-attribute]&#x27;);
            }

            if (!!this.options.editable) {
                this.sandbox.dom.on(this.$el, &#x27;click&#x27;, this.editCellValues.bind(this), &#x27;.editable&#x27;);

                // FIXME does not work with focus - causes endless loop in some cases (husky-validation?)
                this.sandbox.dom.on(this.$el, &#x27;click&#x27;, this.focusOnRow.bind(this), &#x27;tr&#x27;);

                this.sandbox.dom.on(this.$el, &#x27;click&#x27;, function(event) {
                    event.stopPropagation();
                }, &#x27;tr&#x27;);

                this.sandbox.dom.on(window, &#x27;click&#x27;, function() {
                    if (!!this.lastFocusedRow) {
                        this.prepareSave();
                    }
                }.bind(this));
            }

            this.sandbox.dom.on(this.sandbox.dom.window, &#x27;resize&#x27;, this.windowResizeListener.bind(this));


            // Todo trigger event when click on clickable area
            // trigger event when click on clickable area
            // different handling when clicked on checkbox and when clicked on td

            // if (this.options.selectItem &amp;&amp; !this.options.selectItem.clickable)
            //     this.$element.on(&#x27;click&#x27;, &#x27;tbody tr td:first-child()&#x27;, function(event) {

            //         // change checked state
            //         var $input = this.sandbox.dom.$(event.target).find(&quot;input&quot;);
            //         $input.prop(&quot;checked&quot;, !$input.prop(&quot;checked&quot;));

            //         itemId = this.sandbox.dom.$(event.target).parents(&#x27;tr&#x27;).data(&#x27;id&#x27;);

            // if(!!itemId){
            //     this.selectedItemIds.push(itemId);
            //     this.sandbox.once(&#x27;husky.datagrid.item.select&#x27;, itemId);
            // } else {
            //     this.sandbox.once(&#x27;husky.datagrid.item.select&#x27;, event);
            // }

            // stop propagation
            //         event.stopPropagation();
            // }.bind(this));
        },

        /**
         * Shows input and hides span
         * @param event
         */
        editCellValues: function(event) {
            var $target = event.currentTarget,
                $input = this.sandbox.dom.next($target, &#x27;input&#x27;);

            this.lockWidthsOfColumns(this.sandbox.dom.find(&#x27;table th&#x27;, this.$el));

            this.sandbox.dom.hide($target);
            this.sandbox.dom.removeClass($input, &#x27;hidden&#x27;);
            $input[0].select();
        },

        /**
         * Makes the widths of columns fixed when the table is in edit mode
         * prevents changes in column width
         * @param $th array of th elements
         */
        lockWidthsOfColumns: function($th) {

            var width, minwidth;
            this.columnWidths = [];

            this.sandbox.dom.each($th, function(index, $el) {
                minwidth = this.sandbox.dom.css($el, &#x27;min-width&#x27;);
                this.columnWidths.push(minwidth);

                width = this.sandbox.dom.outerWidth($el);
                this.sandbox.dom.css($el, &#x27;min-width&#x27;, width);
                this.sandbox.dom.css($el, &#x27;max-width&#x27;, width);
                this.sandbox.dom.css($el, &#x27;width&#x27;, width);
            }.bind(this));
        },

        /**
         * Resets the min-width of columns and
         * @param $th array of th elements
         */
        unlockWidthsOfColumns: function($th) {
            if (!!this.columnWidths) {
                this.sandbox.dom.each($th, function(index, $el) {
                    // skip columns without data-attribute because the have min/max and normal widths by default
                    if (!!this.sandbox.dom.data($el, &#x27;attribute&#x27;)) {
                        this.sandbox.dom.css($el, &#x27;min-width&#x27;, this.columnWidths[index]);
                        this.sandbox.dom.css($el, &#x27;max-width&#x27;, &#x27;&#x27;);
                        this.sandbox.dom.css($el, &#x27;width&#x27;, &#x27;&#x27;);
                    }
                }.bind(this));
            }
        },

        /**
         * Sets header classes and loads new data
         * Emits husky.datagrid.updated event on success
         * @param event
         */
        changeSorting: function(event) {

            var attribute = this.sandbox.dom.data(event.currentTarget, &#x27;attribute&#x27;),
                $element = event.currentTarget,
                $span = this.sandbox.dom.children($element, &#x27;span&#x27;)[0],
                url, template;

            if (!!attribute &amp;&amp; !!this.data.links.sortable[attribute]) {

                this.sandbox.emit(DATA_SORT);
                this.sort.attribute = attribute;

                if (this.sandbox.dom.hasClass($span, this.sort.ascClass)) {
                    this.sort.direction = &quot;desc&quot;;
                } else {
                    this.sort.direction = &quot;asc&quot;;
                }

                this.addLoader();
                template = this.sandbox.uritemplate.parse(this.data.links.sortable[attribute]);
                url = this.sandbox.uritemplate.expand(template, {sortOrder: this.sort.direction});

                this.load({
                    url: url,
                    success: function() {
                        this.removeLoader();
                        this.sandbox.emit(UPDATED, &#x27;updated sort&#x27;);
                    }.bind(this)
                });
            }
        },

        /**
         * Sets the header classes used for sorting purposes
         * needs this.sort to be correctly initialized
         */
        setHeaderClasses: function() {
            var attribute = this.sort.attribute,
                direction = this.sort.direction,
                $element = this.sandbox.dom.find(&#x27;thead th[data-attribute=&#x27; + attribute + &#x27;]&#x27;, this.$element),
                $span = this.sandbox.dom.children($element, &#x27;span&#x27;)[0];

            if (!!attribute) {

                this.sandbox.dom.addClass($element, &#x27;is-selected&#x27;);

                if (direction === &#x27;asc&#x27;) {
                    this.sandbox.dom.addClass($span, this.sort.ascClass + this.sort.additionalClasses);
                } else {
                    this.sandbox.dom.addClass($span, this.sort.descClass + this.sort.additionalClasses);
                }

            }
        },

        bindCustomEvents: function() {
            var searchInstanceName = &#x27;&#x27;, columnOptionsInstanceName = &#x27;&#x27;;

            this.sandbox.on(&#x27;husky.navigation.size.changed&#x27;, this.windowResizeListener.bind(this));

            // listen for private events
            this.sandbox.on(UPDATE, this.updateHandler.bind(this));

            // listen for public events
            this.sandbox.on(ROW_ADD, this.addRow.bind(this));

            this.sandbox.on(ROW_REMOVE, this.removeRow.bind(this));

            // trigger selectedItems
            this.sandbox.on(ITEMS_GET_SELECTED, this.getSelectedItemsIds.bind(this));

            // checks tablel width
            this.sandbox.on(UPDATE_TABLE, this.windowResizeListener.bind(this));

            this.sandbox.on(DATA_GET, this.provideData.bind(this));

            // filter data
            this.sandbox.on(DATA_SEARCH, this.triggerSearch.bind(this));

            // filter data
            this.sandbox.on(URL_UPDATE, this.updateUrl.bind(this));

            // pagination dropdown item clicked
            this.sandbox.on(&#x27;husky.dropdown.&#x27; + this.dropdownInstanceName + &#x27;.item.click&#x27;, this.changePage.bind(this, null));

            // show-elements dropdown item clicked
            this.sandbox.on(&#x27;husky.dropdown.datagrid-pagination-dropdown-show.item.click&#x27;, function(item) {
                if (this.data.pageSize !== item.id || this.data.total === this.data.numberOfAll) {
                    // show all
                    if (item.id === 0) {
                        // only if not already all are shown
                        if (this.data.total !== this.data.numberOfAll) {
                            this.changePage(this.data.links.all);
                        }
                    } else {
                        this.data.pageSize = item.id;
                        this.changePage(null, {id: 1});
                    }
                }
            }.bind(this));

            // listen to search events
            if (!!this.options.searchInstanceName) {
                if (this.options.searchInstanceName !== &#x27;&#x27;) {
                    searchInstanceName = &#x27;.&#x27; + this.options.searchInstanceName;
                }
                this.sandbox.on(&#x27;husky.search&#x27; + searchInstanceName, this.triggerSearch.bind(this));
                this.sandbox.on(&#x27;husky.search&#x27; + searchInstanceName + &#x27;.reset&#x27;, this.triggerSearch.bind(this, &#x27;&#x27;));
            }

            // listen to search events
            if (this.options.columnOptionsInstanceName || this.options.columnOptionsInstanceName === &#x27;&#x27;) {
                columnOptionsInstanceName = (this.options.columnOptionsInstanceName !== &#x27;&#x27;) ? &#x27;.&#x27; + this.options.columnOptionsInstanceName : &#x27;&#x27;;
                this.sandbox.on(&#x27;husky.column-options&#x27; + columnOptionsInstanceName + &#x27;.saved&#x27;, this.filterColumns.bind(this));
            }
        },


        /**
         * Put focus on table row and remember values
         */
        focusOnRow: function(event) {

            var $tr = event.currentTarget,
                domId = this.sandbox.dom.data($tr, &#x27;dom-id&#x27;);

            this.sandbox.logger.log(&quot;focus on row&quot;, domId);

            if (!!this.lastFocusedRow &amp;&amp; this.lastFocusedRow.domId !== domId) { // new focus
                this.prepareSave();
                this.lastFocusedRow = this.getInputValuesOfRow($tr);
                this.sandbox.logger.log(&quot;focused &quot; + this.lastFocusedRow.domId + &quot; now!&quot;);
            } else if (!this.lastFocusedRow) { // first focus
                this.lastFocusedRow = this.getInputValuesOfRow($tr);
                this.sandbox.logger.log(&quot;focused &quot; + this.lastFocusedRow.domId + &quot; now!&quot;);
            }
        },

        /**
         * Returns an object with the current values of the inputfields, id and domId
         * @param $tr table row
         * @returns {{domId: *, id: *, fields: Array}}
         */
        getInputValuesOfRow: function($tr) {

            var id = this.sandbox.dom.data($tr, &#x27;id&#x27;),
                domId = this.sandbox.dom.data($tr, &#x27;dom-id&#x27;),
                $inputs = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $tr),
                fields = [], field, $td;

            this.sandbox.dom.each($inputs, function(index, $input) {
                $td = this.sandbox.dom.parent($input, &#x27;td&#x27;);
                field = this.sandbox.dom.data($td, &#x27;field&#x27;);

                fields[field] = $input.value;

            }.bind(this));
            return {
                domId: domId,
                id: id,
                fields: fields
            };

        },

        /**
         * Perparse to save new/changed data includes validation
         */
        prepareSave: function() {

            if (!!this.lastFocusedRow) {

                var $tr = this.sandbox.dom.find(&#x27;tr[data-dom-id=&#x27; + this.lastFocusedRow.domId + &#x27;]&#x27;, this.$el),
                    lastFocusedRowCurrentData = this.getInputValuesOfRow($tr),

                    data = {},
                    key,
                    url,
                    isValid = true,
                    valuesChanged = false,
                    isDataEmpty;

                data.id = lastFocusedRowCurrentData.id;

                // validate locally
                if (!!this.options.validation &amp;&amp; !this.sandbox.form.validate(&#x27;#&#x27; + this.elId)) {
                    isValid = false;
                }

                isDataEmpty = this.isDataRowEmpty(lastFocusedRowCurrentData.fields);

                // do nothing when data is not valid or no data exists
                if (!!isValid &amp;&amp; !isDataEmpty) {

                    // check which values changed and remember these
                    for (key in lastFocusedRowCurrentData.fields) {
                        if (this.lastFocusedRow.fields.hasOwnProperty(key) &amp;&amp; this.lastFocusedRow.fields[key] !== lastFocusedRowCurrentData.fields[key]) {
                            data[key] = lastFocusedRowCurrentData.fields[key];
                            valuesChanged = true;
                        }
                    }

                    // trigger save action when data changed
                    if (!!valuesChanged) {

                        this.sandbox.emit(DATA_CHANGED);
                        url = this.getUrlWithoutParams();

                        // save via put
                        if (!!data.id) {
                            this.save(data, &#x27;PUT&#x27;, url + &#x27;/&#x27; + data.id, $tr, this.lastFocusedRow.domId);

                            // save via post
                        } else {
                            this.save(data, &#x27;POST&#x27;, url, $tr, this.lastFocusedRow.domId);
                        }

                        // reset last focused row after save
                        this.lastFocusedRow = null;

                    } else if (this.errorInRow.indexOf(this.lastFocusedRow.domId) !== -1) {
                        this.sandbox.logger.log(&quot;Error in table row!&quot;);

                    } else {
                        // nothing changed - reset immediately
                        this.sandbox.logger.log(&quot;No data changed!&quot;);
                        this.resetRowInputFields($tr);
                        this.unlockWidthsOfColumns(this.sandbox.dom.find(&#x27;table th&#x27;, this.$el));
                    }

                } else {
                    this.sandbox.logger.log(&quot;There seems to be some invalid or empty data!&quot;);
                }

            }
        },

        /**
         * Checks wether data is in row or not
         * @param data fields object
         */
        isDataRowEmpty: function(data) {

            var isEmpty = true, field;

            for (field in data) {
                if (data[field] !== &#x27;&#x27;) {
                    isEmpty = false;
                    break;
                }
            }

            return isEmpty;
        },


        /**
         * Returns url without params
         */
        getUrlWithoutParams: function() {
            var url = this.data.links.self;

            if (url.indexOf(&#x27;?&#x27;) !== -1) {
                return url.substring(0, url.indexOf(&#x27;?&#x27;));
            }

            return url;
        },

        /**
         * Saves changes
         * @param data
         * @param method
         * @param url
         * @param $tr table row
         * @param domId
         */
        save: function(data, method, url, $tr, domId) {

            var message;

            this.sandbox.logger.log(&quot;data to save&quot;, data);
            this.showLoadingIconForRow($tr);

            this.sandbox.util.save(url, method, data)
                .then(function(data, textStatus) {

                    // remove row from error list
                    if (this.errorInRow.indexOf(domId) !== -1) {
                        this.errorInRow.splice(this.errorInRow.indexOf(domId), 1);
                    }

                    this.sandbox.emit(DATA_SAVED, data, textStatus);
                    this.hideLoadingIconForRow($tr);
                    this.resetRowInputFields($tr);
                    this.unlockWidthsOfColumns(this.sandbox.dom.find(&#x27;table th&#x27;, this.$el));

                    // set new returned data
                    this.setDataForRow($tr[0], data);

                }.bind(this))
                .fail(function(jqXHR, textStatus, error) {
                    this.sandbox.emit(DATA_SAVE_FAILED, textStatus, error);
                    this.hideLoadingIconForRow($tr);

                    // remember row with error
                    if (this.errorInRow.indexOf(domId) === -1) {
                        this.errorInRow.push(domId);
                    }

                    message = JSON.parse(jqXHR.responseText);

                    // error in context with database constraints
                    if (!!message.field) {
                        this.showValidationError($tr, message.field);
                    } else {
                        this.sandbox.logger.error(&quot;An error occured during save of changed data!&quot;);
                    }

                }.bind(this));
        },


        /**
         * Sets the data for a row
         * @param $tr dom row
         * @param data
         */
        setDataForRow: function($tr, data) {

            var editables, field, $input;

            // set id
            this.sandbox.dom.data($tr, &#x27;id&#x27;, data.id);
            this.sandbox.dom.attr($tr, &#x27;data-id&#x27;, data.id);

            this.sandbox.util.each(this.sandbox.dom.find(&#x27;td&#x27;, $tr), function(index, $el) {

                editables = this.sandbox.dom.find(&#x27;.editable&#x27;, $el);
                field = this.sandbox.dom.data($el, &#x27;field&#x27;);
                $input = this.sandbox.dom.find(&#x27;input[type=text]&#x27;, $el);

                if (!!field) {
                    if (!!editables &amp;&amp; editables.length === 1) { // set values in spans
                        this.sandbox.dom.html(editables[0], data[field]);
                        this.sandbox.dom.val($input, data[field]);
                    } else { // set values in td
                        this.sandbox.dom.html($el, data[field]);
                    }
                }

            }.bind(this));
        },

        /**
         * Shows loading icon for a tr
         * @param $tr
         */
        showLoadingIconForRow: function($tr) {
            if (!!this.options.progressRow) {
                var domId = this.sandbox.dom.data($tr, &#x27;dom-id&#x27;);
                this.sandbox.dom.addClass(&#x27;tr[data-dom-id=&#x27; + domId + &#x27;] td:last&#x27;, &#x27;is-loading&#x27;);
            }
        },

        /**
         * Hides loading icon for a tr
         * @param $tr
         */
        hideLoadingIconForRow: function($tr) {
            if (!!this.options.progressRow) {
                var domId = this.sandbox.dom.data($tr, &#x27;dom-id&#x27;);
                this.sandbox.dom.removeClass(&#x27;tr[data-dom-id=&#x27; + domId + &#x27;] td&#x27;, &#x27;is-loading&#x27;);
            }
        },

        /**
         * Sets the validation error class for a dom element
         * @param $domElement
         * @param field name of field which caused the error
         */
        showValidationError: function($domElement, field) {

            var $td = this.sandbox.dom.find(&#x27;td[data-field=&#x27; + field + &#x27;]&#x27;, $domElement)[0],
                $input = this.sandbox.dom.find(&#x27;input&#x27;, $td)[0];

            if (this.sandbox.dom.hasClass($td, &#x27;husky-validate-success&#x27;)) {
                this.sandbox.dom.removeClass($td, &#x27;husky-validate-success&#x27;);
            }

            this.sandbox.dom.addClass($td, &#x27;husky-validate-error&#x27;);

            // add class for serverside validation error
            // TODO remove this when correct validation type is implmented
            if (!this.sandbox.dom.hasClass($input, &#x27;server-validation-error&#x27;)) {
                this.sandbox.dom.addClass($input, &#x27;server-validation-error&#x27;);
            }
        },

        /**
         *  Hides input fields and displays new content for table row
         * @param $tr
         */
        resetRowInputFields: function($tr) {

            var $inputFields = this.sandbox.dom.find(&#x27;input[type=text]:not(.hidden)&#x27;, $tr),
                content, $span;

            this.sandbox.util.each($inputFields, function(index, $field) {

                // remove css class for server side validation error
                // TODO: remove this when validation type is implemented
                if (this.sandbox.dom.hasClass($field, &#x27;server-validation-error&#x27;)) {
                    this.sandbox.dom.removeClass($field, &#x27;server-validation-error&#x27;);
                }

                content = this.sandbox.dom.$($field).val();
                $span = this.sandbox.dom.prev($field, &#x27;.editable&#x27;);
                $span.text(content);

                this.sandbox.dom.addClass($field, &#x27;hidden&#x27;);
                this.sandbox.dom.show($span);

            }.bind(this));
        },

        /**
         * Provides data of the list to the caller
         */
        provideData: function() {
            this.sandbox.emit(DATA_PROVIDE, this.data);
        },

        /**
         * Updates data in datagrid
         * Called when husky.datagrid.update event emitted
         * Emits husky.datagrid.updated event on success
         */
        updateHandler: function() {
            this.resetItemSelection();
            this.resetSortingOptions();

            this.load({
                url: this.data.links.self,
                success: function() {
                    this.removeLoader();
                    this.sandbox.emit(UPDATED);
                }.bind(this)
            });
        },

        /**
         * triggers an api search
         * @param {String} searchString The String that will be searched
         * @param {String|Array} searchFields Fields that will be included into the search
         */
        triggerSearch: function(searchString, searchFields) {

            var template, url;

            this.addLoader();
            template = this.sandbox.uritemplate.parse(this.data.links.find);
            url = this.sandbox.uritemplate.expand(template, {searchString: searchString, searchFields: searchFields});

            this.load({
                url: url,
                success: function() {
                    this.removeLoader();
                    this.sandbox.emit(UPDATED, &#x27;updated after search&#x27;);
                }.bind(this)
            });
        },

        /**
         * updates the current url by given parameter object
         * @param {Object} parameters Object key is used as parameter name, value as parameter value
         */
        updateUrl: function(parameters) {

            var url, key;

            this.addLoader();
            url = this.currentUrl;

            for (key in parameters) {
                url = this.setGetParameter(url, key, parameters[key]);
            }

            this.load({
                url: url,
                success: function() {
                    this.removeLoader();
                    this.sandbox.emit(UPDATED);
                }.bind(this)
            });
        },

        /**
         * function updates an url by a given parameter name and value and returns it. The parameter is either added or updated.
         * If value is not set, the parameter will be removed from url
         * @param {String} url Url string to be updated
         * @param {String} paramName Parameter which should be added / updated / removed
         * @param {String|Null} paramValue Value of the parameter. If not set, parameter will be removed from url
         * @returns {String} updated url
         */
        setGetParameter: function(url, paramName, paramValue){
            if (url.indexOf(paramName + &quot;=&quot;) &gt;= 0)
            {
                var prefix = url.substring(0, url.indexOf(paramName)),
                    suffix = url.substring(url.indexOf(paramName));
                suffix = suffix.substring(suffix.indexOf(&#x27;=&#x27;) + 1);
                suffix = (suffix.indexOf(&#x27;&amp;&#x27;) &gt;= 0) ? suffix.substring(suffix.indexOf(&#x27;&amp;&#x27;)) : &#x27;&#x27;;
                if (!!paramValue) {
                    url = prefix + paramName + &#x27;=&#x27; + paramValue + suffix;
                } else {
                    if (url.substr(url.indexOf(paramName)-1,1) === &#x27;&amp;&#x27; ) {
                        url = url.substring(0,prefix.length-1) + suffix;
                    } else {
                        url = prefix + suffix.substring(1, suffix.length);
                    }
                }
            }
            else if (!!paramValue)
            {
                if (url.indexOf(&quot;?&quot;) &lt; 0)
                    url += &quot;?&quot; + paramName + &quot;=&quot; + paramValue;
                else
                    url += &quot;&amp;&quot; + paramName + &quot;=&quot; + paramValue;
            }
            return url;
        },


        /**
         * is called when columns are changed
         */
        filterColumns: function(fieldsData) {

            var template, url,
                parsed = this.parseFieldsData(fieldsData);

            this.addLoader();

            template = this.sandbox.uritemplate.parse(this.data.links.filter);
            url = this.sandbox.uritemplate.expand(template, {fieldsList: parsed.urlFields.split(&#x27;,&#x27;)});

            this.options.columns = parsed.columns;

            this.sandbox.dom.width(this.$element, &#x27;100%&#x27;);
            if (!!this.options.contentContainer) {
                this.sandbox.dom.css(this.options.contentContainer, &#x27;max-width&#x27;, &#x27;&#x27;);
            }

            this.load({
                url: url,
                success: function() {
                    this.removeLoader();
                    this.sandbox.emit(UPDATED, &#x27;updated after search&#x27;);
                }.bind(this)
            });
        },


        /**
         * Renders datagrid element in container
         * Binds DOM events
         */
        render: function() {
            // add full-width class
            if (this.options.fullWidth === true) {
                this.sandbox.dom.addClass(this.$element, constants.fullWidthClass);
            }

            this.$originalElement.html(this.$element);
            this.bindDOMEvents();

            // initialize validation
            if (!!this.options.validation) {
                this.sandbox.form.create(this.$el);
            }
        },

        /**
         * this function is responsible for responsiveness of datagrid and is called everytime after resizing window and after initialization
         */
        windowResizeListener: function() {

            var finalWidth,
                contentPaddings = 0,
                content = !!this.options.contentContainer ? this.options.contentContainer : this.$el,
                tableWidth = this.sandbox.dom.width(this.$table),
                tableOffset = this.sandbox.dom.offset(this.$table),
                contentWidth = this.sandbox.dom.width(content),
                windowWidth = this.sandbox.dom.width(this.sandbox.dom.window),
                overlaps = false,
                originalMaxWidth = contentWidth;

            tableOffset.right = tableOffset.left + tableWidth;


            if (!!this.options.contentContainer &amp;&amp; !!this.originalMaxWidth) {
                // get original max-width and right margin
                originalMaxWidth = this.originalMaxWidth;
                contentPaddings = this.contentPaddings;
            }

            // if table is greater than max content width
            if (tableWidth &gt; originalMaxWidth - contentPaddings &amp;&amp; contentWidth &lt; windowWidth - tableOffset.left) {
                // adding this class, forces table cells to shorten long words
                this.sandbox.dom.addClass(this.$element, &#x27;oversized&#x27;);
                overlaps = true;
                // reset table width and offset
                tableWidth = this.sandbox.dom.width(this.$table);
                tableOffset.right = tableOffset.left + tableWidth;
            }

            // tablecontainer should have width of table in normal cases
            finalWidth = tableWidth;

            // if table &gt; window-size set width to available space
            if (tableOffset.right + this.contentMarginRight &gt; windowWidth) {
                finalWidth = windowWidth - tableOffset.left;
            } else {
                // set scroll position back
                this.sandbox.dom.scrollLeft(this.$element, 0);
            }

            // width is not allowed to be smaller than the width of content
            if (finalWidth &lt; contentWidth) {
                finalWidth = contentWidth;
            }

            // if contentContainer is set, adapt maximum size
            if (!!this.options.contentContainer) {
                this.sandbox.dom.css(this.options.contentContainer, &#x27;max-width&#x27;, finalWidth + contentPaddings);
                finalWidth = this.sandbox.dom.width(this.options.contentContainer);
                if (!overlaps) {
                    // if table does not overlap border, set content to original width
                    this.sandbox.dom.css(this.options.contentContainer, &#x27;max-width&#x27;, &#x27;&#x27;);
                }
            }

            // now set width
            this.sandbox.dom.width(this.$element, finalWidth);

            // check scrollwidth and add class
            if (this.sandbox.dom.get(this.$tableContainer, 0).scrollWidth &gt; finalWidth) {
                this.sandbox.dom.addClass(this.$tableContainer, &#x27;overflow&#x27;);

                // if overflown and in full width mode reduce list-width
                if (this.options.fullWidth === true) {
                    finalWidth = finalWidth - constants.overflowIconSpacing;
                    this.sandbox.dom.width(this.$element, finalWidth);
                }

            } else {
                this.sandbox.dom.removeClass(this.$tableContainer, &#x27;overflow&#x27;);
            }
        },

        /**
         * Adds loading icon and keeps width and height
         * @returns {*}
         */
        addLoader: function() {
            this.$element
                .outerWidth(this.$element.outerWidth())
                .outerHeight(this.$element.outerHeight())
                .empty();

            var $container = this.sandbox.dom.createElement(&#x27;&lt;div class=&quot;datagrid-loader&quot;/&gt;&#x27;);
            this.sandbox.dom.append(this.$element, $container);

            this.sandbox.start([{
                name: &#x27;loader@husky&#x27;,
                options: {
                    el: $container,
                    size: &#x27;100px&#x27;,
                    color: &#x27;#cccccc&#x27;
                }
            }]);

            return this.$element;
        },

        /**
         * Removes loading icon, width and height of container
         * @returns {*}
         */
        removeLoader: function() {
            return this.$element.outerHeight(&quot;&quot;).outerWidth(&quot;&quot;);
            this.sandbox.stop(this.sandbox.dom.find(&#x27;.datagrid-loader&#x27;, this.$element));

            return this.$element;
        },

        /**
         * Returns selected items either via callback or else via husky.datagrid.items.selected event
         * Gets called on husky.datagrid.items.get-selected event
         * @param callback
         */
        getSelectedItemsIds: function(callback) {

            // get selected items
            var ids = this.getIdsOfSelectedRows();

            if (typeof callback === &#x27;function&#x27;) {
                callback(ids);
            } else {
                this.sandbox.emit(ITEMS_SELECTED, ids);
            }
        },

        templates: {

            showElements: function(id) {
                var desc = &#x27;&#x27;;
                if (this.data.total === this.data.numberOfAll) {
                    desc = this.sandbox.translate(&#x27;pagination.show-all-elements&#x27;);
                } else {
                    desc = this.sandbox.translate(&#x27;pagination.show&#x27;) +&#x27; &lt;strong&gt;&#x27;+ this.data.total +&#x27;&lt;/strong&gt; &#x27;+ this.sandbox.translate(&#x27;pagination.elements-of&#x27;) +&#x27; &#x27;+ this.data.numberOfAll;
                }

                return [
                    &#x27;&lt;div class=&quot;show-elements&quot;&gt;&#x27;,
                        &#x27;&lt;div class=&quot;dropdown-trigger&quot; id=&quot;&#x27;+ id +&#x27;&quot;&gt;&#x27;+ desc +&#x27;&lt;span class=&quot;dropdown-toggle&quot;&gt;&lt;/span&gt;&lt;/div&gt;&#x27;,
                    &#x27;&lt;/div&gt;&#x27;
                ].join(&#x27;&#x27;);
            },

            removeRow: function() {
                return [
                    &#x27;&lt;span class=&quot;icon-remove pointer&quot;&gt;&lt;/span&gt;&#x27;
                ].join(&#x27;&#x27;);
            },

            progressRow: function() {
                return [
                    &#x27;&lt;span class=&quot;&quot;&gt;&lt;/span&gt;&#x27;
                ].join(&#x27;&#x27;);
            },

            checkbox: function(data) {
                var id, name;

                data = data || {};
                id = (!!data.id) ? &#x27; id=&quot;&#x27; + data.id + &#x27;&quot;&#x27; : &#x27;&#x27;;
                name = (!!data.name) ? &#x27; name=&quot;&#x27; + data.name + &#x27;&quot;&#x27; : &#x27;&#x27;;

                return [
                    &#x27;&lt;div class=&quot;custom-checkbox&quot;&gt;&#x27;,
                        &#x27;&lt;input&#x27;, id, name, &#x27; type=&quot;checkbox&quot; data-form=&quot;false&quot;/&gt;&#x27;,
                        &#x27;&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;&#x27;,
                    &#x27;&lt;/div&gt;&#x27;
                ].join(&#x27;&#x27;);
            },

            radio: function(data) {
                var id, name;

                data = data || {};
                id = (!!data.id) ? &#x27; id=&quot;&#x27; + data.id + &#x27;&quot;&#x27; : &#x27;&#x27;;
                name = (!!data.name) ? &#x27; name=&quot;&#x27; + data.name + &#x27;&quot;&#x27; : &#x27;&#x27;;

                return [
                    &#x27;&lt;div class=&quot;custom-radio&quot;&gt;&#x27;,
                        &#x27;&lt;input&#x27;, id, name, &#x27; type=&quot;radio&quot;/&gt;&#x27;,
                        &#x27;&lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;&#x27;,
                    &#x27;&lt;/div&gt;&#x27;
                ].join(&#x27;&#x27;);
            }
        }
    };
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
